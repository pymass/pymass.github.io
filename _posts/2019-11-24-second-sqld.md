---
published: true
layout: single
title: "SQLD 이론 정리 - 2과목"
category: SQL
comments: true
toc: true
toc_sticky: true
use_math: true
---

시험이 6일 남은 시점에서 2과목 공부를 시작한다.

남은 시간 열심히 공부하면 충분히 합격할 수 있을거라 믿는다.

시험 장소가 발표되었는데 건국대에서 시험을 본다.

지난번 ADSP는 단국대에서 봤던 것 같은데 시험장이 계속 바뀌는 것 같다.

<br/>

# 1. SQL 기본

**관계형 데이터베이스**

- 데이터베이스 종류는 계층형, 네트워크형, 관계형 등이 있다.
- 계층형은 트리(Tree) 형태의 자료구조에 데이터를 저장, 관리한다. (1대 N)
- 네트워크형은 오너(Owner)와 멤버(Member) 형태로 데이터를 저장한다. (1대 N, M대 N)
- 관계형은 릴레이션에 데이터를 저장, 관리한다. (집합 연산 + 관계 연산)

<br/>

**집합 연산**

- 합집합 : 두 개의 릴레이션을 하나로 합한다 (중복된 행은 한 번만 조회된다)
- 차집합 : 본래 릴레이션에는 존재하고 다른 릴레이션에는 존재하지 않는 것을 조회한다.
- 교집합 : 두 개의 릴레이션 간에 공통된 것을 조회한다.
- 곱집합 : 각 릴레이션에 존재하는 모든 데이터를 조합하여 연산한다.

<br/>

**관계 연산**

- 선택 연산 : 릴레이션에서 조건에 맞는 행만을 조회한다.
- 투영 연산 : 릴레이션에서 조건에 맞는 속성만을 조회한다.
- 결합 연산 : 여러 릴레이션의 공통된 속성을 사용해서 새로운 릴레이션을 만들어 낸다.
- 나누기 연산 : 기준 릴레이션에서 나누는 릴레이션이 가지고 있는 속성과 동일한 값을 가지는 행을 추출하고 나누는 릴레이션의 속성을 삭제한 후 중복된 행을 제거하는 연산이다.

<br/>

**테이블의 구조**

<img src="https://i.ibb.co/1dzV7RF/image.png" alt="image" border="0">

- 기본키는 하나의 테이블에서 유일성과 최소성을 만족하면서 해당 테이블을 대표하는 것이다.
- 테이블은 행과 칼럼으로 구성된다. 그중에서 행은 하나의 테이블에 저장되는 값으로 튜플이라고도 한다.
- 칼럼은 어떤 데이터를 저장하기 위한 필드로 속성이라고도 한다.
- 외래키는 다른 테이블의 기본키를 참조하는 칼럼이다.
- 외래키는 관계연산 중에서 결합연산을 하기 위해서 사용한다.

<br/>

**SQL 종류**

- DDL(Data Definition Language) : 관계형 데이터베이스의 구조를 정의하는 언어 (Create, Alter, Drop, Rename)
- DML(Data Manipulation Language) : 테이블에서 입력, 수정, 삭제, 조회 (Insert, Update, Delete, Select)
- DCL(Data Control Language) : 데이터베이스 사용자에게 권한을 부여하거나 회수 (Grant, Revoke)
- TCL(Transaction Control Language) : 트랜잭션을 제어하는 명령 (Commit, Rollback)

<br/>

**트랜잭션의 특성**

- 원자성
  - 트랜잭션은 데이터베이스 연산의 전부 또는 일부 실행만이 있다.
  - 트랜잭션의 처리가 완전히 끝나지 않았을 경우는 전혀 이루어지지 않는 것과 같아야 한다.
- 일관성
  - 트랜잭션 실행 결과로 데이터베이스의 상태가 모순되지 않아야 한다.
  - 트랜잭션 실행 후에도 일관성이 유지되어야 한다.
- 고립성
  - 트랜잭션 실행 중에 생성하는 연산의 중간결과는 다른 트랜잭션이 접근할 수 없다.
  - 즉, 부분적인 실행결과를 다른 트랜잭션이 볼 수 없다.
- 연속성
  - 트랜잭션이 그 실행을 성공적으로 완료하면 그 결과는 영구적 보장이 되어야 한다.

<br/>

**SQL 실행 순서**

1. 파싱 : SQL문의 문법을 확인하고 구문분석한다. (구문분석한 SQL문은 Library Cache에 저장)
2. 실행 : 옵티마이저가 수립한 실행계획에 따라 SQL을 실행한다.
3. 인출 : 데이터를 읽어서 전송한다.

<br/>

**테이블 관리 SQL문**

- Create table : 새로운 테이블 생성 (기본키, 외래키, 기타 제약사항 설정)
- Alter table : 생성된 테이블을 변경 (칼럼 추가, 변경, 삭제 + 기본키 설정, 외래키 설정)
- Drop table : 해당 테이블 삭제 (저장된 데이터도 전부 삭제된다)
- constraint : 기본키(외래키)의 이름을 지정
- CASCADE : 참조 관계가 있을 경우 참조되는 데이터도 자동으로 삭제
  - ON DELETE CASCADE : 참조 테이블 삭제되면 자동으로 자신도 삭제 (참조 무결성을 준수할 수 있음)

<br/>

**테이블 변경**

- ALTER TABLE ~ ADD : 칼럼을 추가
- ALTER TABLE ~ MODIFY : 칼럼을 변경
- ALTER TABLE ~ DROP COLUMN : 칼럼을 삭제
- ALTER TABLE ~ RENAME COLUMN ~ TO : 칼럼명 변경

<br/>

**테이블 삭제**

- DROP TABLE : 테이블 구조 및 데이터 전부 삭제
- DROP TABLE CASCADE CONSTRAINT : 참조된 제약사항까지 모두 삭제

<br/>

**뷰 생성과 삭제**

- 뷰란 테이블로부터 유도된 가상의 테이블이다.
- 뷰에 대한 입력, 수정, 삭제에는 제약이 발생한다.
- CREATE VIEW : 뷰를 생성
- DROP VIEW : 뷰를 삭제

<br/>

**뷰의 장점과 단점**

| 장점                                                | 단점                                 |
| --------------------------------------------------- | ------------------------------------ |
| 특정 칼럼만 조회할 수 있기 때문에 보안 기능이 있다. | 뷰는 독자적인 인덱스를 만들 수 없다. |
| 데이터 관리가 간단하다.                             | 삽입, 수정, 삭제 연산이 제약된다.    |
| SELECT문이 간단해진다.                              | 데이터 구조를 변경할 수는 없다.      |
| 하나의 테이블에 여러 개의 뷰를 생성할 수 있다.      |                                      |

<br/>

**DML**

- INSERT : 데이터를 입력 (최종적으로 데이터를 저장하려면 COMMIT을 해야함)
  - SELECT 문과 같이 사용 가능
  - NOLOGGING 옵션 사용 시 메모리 영역을 생략하고 기록
- UPDATE : 입력된 데이터를 수정
- DELETE : 데이터를 삭제 (테이블의 용량이 초기화되지 않는다)
- TRUNCATE : 데이터를 삭제 (테이블의 용량을 초기화)
- SELECT : 데이터를 조회
- ORDER BY : 데이터를 정렬 (기본적으로 오름차순으로 정렬)
  - ORDER BY는 데이터베이스에 부하를 주기 때문에 INDEX_DESC로 회피할 수 있다.
- DISTINCT : 칼럼명 앞에 지정하여 중복된 데이터를 한 번만 조회 (UNIQUE 값만 보여줌)
- ALIAS : 테이블명이나 칼럼명이 너무 길어서 간략하게 사용할 때 (=AS)

<br/>

**WHERE 문 연산자**

|     비교 연산자     |                        설명                         |
| :-----------------: | :-------------------------------------------------: |
|          =          |                   같은 것을 조회                    |
|          <          |                   작은 것을 조회                    |
|         <=          |                작거나 같은 것을 조회                |
|          >          |                    큰 것을 조회                     |
|         >=          |                크거나 같은 것을 조회                |
|         !=          |                 같지 않은 것을 조회                 |
|         ^=          |                 같지 않은 것을 조회                 |
|         <>          |                 같지 않은 것을 조회                 |
|    NOT 칼럼명 =     |                 같지 않은 것을 조회                 |
|    NOT 칼럼명 >     |                 크지 않은 것을 조회                 |
|         AND         |               조건을 모두 만족해야 참               |
|         OR          |             조건 중 하나만 만족해도 참              |
|         NOT         |     참이면 거짓으로 바꾸고 거짓이면 참으로 바꿈     |
| LIKE '비교 문자열'  |    비교 문자열을 조회한다 ('%'는 모든 것을 의미)    |
|   BETWEEN A AND B   |             A와 B 사이의 값을 조회한다              |
|      IN (list)      | OR을 의미하며 list 값 중에 하나만 일치해도 조회된다 |
|       IS NULL       |                 NULL 값을 조회한다                  |
| NOT BETWEEN A AND B |      A와 B 사이의 해당하지 않는 값을 조회한다       |
|    NOT IN (list)    |            list와 불일치한 것을 조회한다            |
|     IS NOT NULL     |            NULL 값이 아닌 것을 조회한다             |

<br/>

**와일드카드 (정규표현식과 비슷)**

- % : 어떤 문자를 포함한 모든 것을 조회한다
- _ : 한 개의 단일 문자를 의미

<br/>

**NULL 관련 함수**

- NVL
  - NULL이면 다른 값으로 바꾸는 함수이다.
  - NVL(MGR, 0)은 MGR 칼럼이 NULL이면 0으로 바꾼다
- NVL2
  - NVL함수와 DECODE를 하나로 만든 것이다.
  - NVL2(MGR, 1, 0)은 MGR 칼럼이 NULL이 아니면 1을, NULL이면 0으로 바꾼다
- NULLIF
  - 두 개의 값이 같으면 NULL을, 같지 않으면 첫 번째 값을 반환한다.
  - NULLIF(exp1, exp2)은 exp1과 exp2가 같으면 NULL을, 같지 않으면 exp1을 반환한다
- COALESCE
  - COALESCE(mgr, 1)은 mgr이 NULL이 아니면 1을 반환한다

<br/>

**집계함수**

| 집계함수 | 설명            |
| :------: | :-------------- |
| COUNT()  | 행 수를 조회    |
|  SUM()   | 합계를 계산     |
|  AVG()   | 평균을 계산     |
|  MAX()   | 최대값을 계산   |
|  MIN()   | 최소값을 계산   |
| STDDEV() | 표준편차를 계산 |
| VARIAN() | 분산을 계산     |

<br/>

**SELECT 실행순서**

SELECT문의 실행 순서는 FROM, WHERE, GROUP BY, HAVING, SELECT, ORDER BY순으로 실행된다

<br/>

**형변환 함수**

- 형변환 함수에는 명시적 형변환과 암시적 형변환이 있다.
- 암시적 형변환이란 개발자가 형변환을 하지 않은 경우 데이터베이스 관리 시스템이 자동으로 형변환하는 것을 의미한다.
- TO_NUMBER(문자열) : 문자열을 숫자로 변환한다.
- TO_CHAR(숫자 혹은 날짜, [FORMAT]) : 숫자 혹은 문자를 지정된 FORMAT의 문자로 변환한다.
- TO_DATE(문자열, FORMAT) : 문자열을 지정된 FORMAT의 날짜형으로 변환한다

<br/>

**내장형 함수**

- DUAL 테이블 : 임시로 사용할 수 있는 DUMMY 테이블이다
- ACSII(문자) : 문자 혹은 숫자를 ACSII 코드 값으로 변환한다
- CHAR(ACSII 코드 값) : ACSII 코드 값을 문자로 변환한다
- SUBSTR(문자열,m,n) : 문자열에서 m번째 위치부터 n개를 자른다
- CONCAT(문자열1, 문자열2) : 문자열1번과 문자열2번을 결합한다
- LOWER(문자열) : 영문자를 소문자로 변환한다
- UPPER(문자열) : 영문자를 대문자로 변환한다
- LENGTH 혹은 LEN(문자열) : 공백을 포함해서 문자열의 길이를 알려준다
- LTRIM(문자열, 지정문자) : 왼쪽에 지정된 문자를 삭제한다 (지정된 문자를 생략하면 공백을 삭제)
- RTRIM(문자열, 지정문자) : 오른쪽에 지정된 문자를 삭제한다 (지정된 문자를 생략하면 공백을 삭제)
- TRIM(문자열, 지정된문자) : 왼쪽 및 오른쪽 지정된 문자를 삭제한다 (지정된 문자를 생략하면 공백을 삭제)
- SYSDATE : 오늘의 날짜를 날짜형 타입으로 알려준다
- EXTRACT('YEAR' I 'MONTH' I 'DAY' from d) : 날짜에서 년, 월, 일을 조회한다
- ABS(숫자) : 절대값을 돌려준다.
- SIGN(숫자) : 양수, 음수, 0을 구별한다.
- MOD(숫자1, 숫자2) : 숫자1을 숫자2로 나누어 나머지를 계산한다.
- CEIL/CEILING(숫자) : 숫자보다 크거나 같은 최소의 정수를 돌려준다.
- FLOOR(숫자) : 숫자보다 작거나 같은 최대의 정수를 돌려준다.
- ROUND(숫자, m) : 소수점 m 자리에서 반올림한다. (m의 기본값은 0이다)
- TRUNC(숫자, m) : 소수점 m 자리에서 절삭한다. (m의 기본값은 0이다)

<br/>

**기타 구문**

- DECODE : IF문을 구현할 수 있다. 특정 조건이 참이면 A, 거짓이면 B로 응답하게 한다.

- CASE : 조건문을 사용할 수 있다. (CASE ~ WHEN ~ THEN ~ ELSE ~ END)

- ROWNUM : 조회할 때 행의 갯수를 제한한다

- ROWID : 데이터를 구분할 수 있는 유일한 값이다.

  - ROWID 구조

    | 구조          | 길이  | 설명                                                         |
    | ------------- | ----- | ------------------------------------------------------------ |
    | 오브젝트 번호 | 1~6   | 오브젝트 별로 유일한 값을 가지고 있으며, 해당 오브젝트가 속해 있는 값이다 |
    | 상대 파일번호 | 7~9   | 테이블스페이스에 속해 있는 데이터 파일에 대한 상대 파일번호이다 |
    | 블록 번호     | 10~15 | 데이터 파일 내부에서 어느 블록에 데이터가 있는지 알려준다    |
    | 데이터 번호   | 16~18 | 데이터 블록에 저장되어 있는 순서를 의미한다.                 |

- WITH : 서브쿼리를 사용해서 임시 테이블이나 뷰처럼 사용할 수 있다

- GRANT : 데이터베이스 사용자에게 권한을 부여한다

  - 권한의 종류

    |    권한    | 설명                                                         |
    | :--------: | ------------------------------------------------------------ |
    |   SELECT   | 지정된 테이블에 대해서 SELECT 권한을 부여한다                |
    |   INSERT   | 지정된 테이블에 대해서 INSERT 권한을 부여한다                |
    |   UPDATE   | 지정된 테이블에 대해서 UPDATE 권한을 부여한다                |
    |   DELETE   | 지정된 테이블에 대해서 DELETE 권한을 부여한다                |
    | REFERENCES | 지정된 테이블을 참조하는 제약조건을 생성하는 권한을 부여한다 |
    |   ALTER    | 지정된 테이블에 대해서 수정할 수 있는 권한을 부여한다        |
    |   INDEX    | 지정된 테이블에 대해서 인덱스를 생성할 수 있는 권한을 부여한다 |
    |    ALL     | 테이블에 대한 모든 권한을 부여한다                           |

  - WITH GRANT OPTION

    | GRANT 옵션        | 설명                                                  |
    | ----------------- | ----------------------------------------------------- |
    | WITH GRANT OPTION | 특정 사용자에게 권한을 부여할 수 있는 권한을 부여한다 |
    | WITH ADMIN OPTION | 테이블에 대한 모든 권한을 부여한다                    |

- REVOKE : 사용자에게 부여된 권한을 회수한다.

<br/>

**TCL**

- COMMIT : INSERT, UPDATE, DELETE문으로 변경한 데이터를 데이터베이스에 반영한다
- ROLLBACK : 변경 내용을 모두 취소한다. (이전에 COMMIT한 곳까지 취소)
- SAVEPOINT : 저장점 지정 시 지정된 위치까지만 ROLLBACK 할 수 있다.

<br/>

# 2. SQL 활용

**JOIN**

1. EQUI(등가) 조인

   두 개의 테이블 간에 일치하는 것을 조인한다

2. INNER 조인

   EQUI와 동일하나 표준 SQL 구문이다.

3. INTERSECT 연산

   두 개의 테이블에서 교집합을 조회한다

4. NON-EQUI(비등가) 조인

   정확하게 일치하지 않는 것을 조인한다.

5. OUTER 조인

   두 개의 테이블 간에 교집합을 조회하고 한쪽 테이블에만 있는 데이터도 포함시켜 조인한다 (LEFT, RIGTH로 방향 지정 가능)

6. CROSS 조인

   조인 조건 구 없이 2개의 테이블을 하나로 조인한다 (카테시안 곱이 발생한다)

<br/>

**UNION**

1. UNION

   - 두 개의 테이블을 하나로 만드는 연산이다 
   - 두 테이블의 칼럼 수, 데이터 형식이 모두 일치해야
   - 합치면서 중복을 제거한다
   - 정렬 과정이 발생한다

2. UNION ALL

   단순하게 테이블을 합친다 (중복 제거 X, 정렬 X)

<br/>

**MINUS**

MINUS 연산은 두 개의 테이블에서 차집합을 조회한다.

<br/>

**계층형 조회 (CONNECT BY)**

CONNECT BY는 트리 형태의 구조로 질의를 수행하는 것으로 START WITH구는 시작 조건이고, CONNECT BY PRIOR는 조인 조건이다

- CONNECT BY 키워드

  | 키워드              | 설명                                                         |
  | ------------------- | ------------------------------------------------------------ |
  | LEVEL               | 검색 항목의 깊이를 의미한다. 즉, 계층구조에서 가장 상위 레벨이 1이 된다 |
  | CONNECT_BY_ROOT     | 계층구조에서 가장 최상위 값을 표시한다                       |
  | CONNECT_BY_ISLEAF   | 계층구조에서 가장 최하위를 표시한다                          |
  | SYS_CONNECT_BY_PATH | 계층구조의 전체 전개 경로를 표시한다                         |
  | NOCYCLE             | 순환구조가 발생지점까지만 전개된다                           |
  | CONNECT_BY_ISCYCLE  | 순환구조 발생 지점을 표시한다                                |

<br/>

**서브쿼리(Subquery)**

- Subquery는 SELECT문 내에 다시 SELECT문을 사용하는 SQL문이다.

- 서브쿼리 밖에 있는 SELECT문은 메인쿼리이다.

- FROM구에 SELECT문을 사용한 것이 인라인 뷰이다.

- 서브쿼리 종류

  | 서브쿼리 종류    | 설명                                             |
  | ---------------- | ------------------------------------------------ |
  | 단일 행 서브쿼리 | 결과가 한 행만 조회(=, <, > 등을 사용)           |
  | 다중 행 서브쿼리 | 결과가 여러 행 조회(IN, ANY, ALL, EXISTS를 사용) |

<br/>

**다중 행 서브쿼리**

- 다중 행 비교 연산자

  | 다중 행 연산     | 설명                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | IN(Subquery)     | Main query의 비교조건이 Subquery의 결과 중 하나만 동일하면 참이 된다(OR조건) |
  | ALL(Subquery)    | Main query와 Subquery의 결과가 모두 동일하면 참이 된다       |
  | ANY(Subquery)    | Main query와 비교조건이 Subquery의 결과 중 하나 이상 동일하면 참이 된다 |
  | EXISTS(Subquery) | Main query와 Subquery의 결과가 하나라도 존재하면 참이 된다   |

<br/>

**스칼라 서브쿼리**

스칼라 서브쿼리는 반드시 한 행과 한 칼럼만 반환하는 서브쿼리이다

<br/>

**연관 서브쿼리**

연관 서브쿼리는 서브쿼리 내에서 메인쿼리 내의 칼럼을 사용하는 것을 의미한다

<br/>

**그룹 함수**

- ROLLUP : GROUP BY의 칼럼에 대해서 Subtotal을 만들어줌
- GROUPING : ROLLUP, CUBE, GROUPING SETS에서 생성되는 합계 값을 구분하기 위한 함수 (합계 값은 1, 아니면 0)
- GROUPING SETS : GROUP BY에 나오는 칼럼의 순서와 관계없이 다양한 소계를 만들 수 있다 (개별적으로 처리)
- CUBE : 제시한 칼럼에 대해서 결합 가능한 모든 집계를 계산한다 (조합할 수 있는 모든 경우의 수)

<br/>

**윈도우 함수**

윈도우 함수는 행과 행 간의 관계를 정의하기 위해서 제공되는 함수이다.

|        구조         | 설명                                                         |
| :-----------------: | ------------------------------------------------------------ |
|   ARGUMENTS(인수)   | 윈도우 함수에 따라서 0~N개의 인수를 설정한다                 |
|    PARTITION BY     | 전체 집합을 기준에 의해 소그룹으로 나눈다                    |
|      ORDER BY       | 어떤 항목에 대해서 정렬한다                                  |
|      WINDOWING      | 행 기준의 범위를 정함(ROWS는 물리적 결과, RANGE는 논리적 결과) |
|        ROWS         | 부분집합인 윈도우 크기를 물리적 단위로 행의 집합을 지정      |
|        RANGE        | 논리적인 주소에 의해 행 집합을 지정                          |
|    BETWEEN ~ AND    | 윈도우의 시작과 끝의 위치를 지정한다                         |
| UNBOUNDED PROCEDING | 윈도우의 시작 위치가 첫 번째 행임을 의미                     |
| UNBOUNDED FOLLOWING | 윈도우 마지막 위치가 마지막 행임을 의미                      |
|     CURRENT ROW     | 윈도우 시작 위치가 현재 행임을 의미                          |

<br/>

**순위 함수**

윈도우 함수는 특정 항목과 파티션에 대해서 순위를 계산할 수 있는 함수를 제공한다

- RANK : 특정항목 및 파티션에 대해서 순위를 계산 (동일한 순위는 동일한 값이 부여)
- DENSE_RANK : 동일한 순위를 하나의 건수로 계산
- ROW_NUMBER : 동일한 순위에 대해서 고유의 순위를 부여

<br/>

**집계함수**

- SUM : 파티션 별로 합계를 계산한다
- AVG : 파티션 별로 평균을 계산한다
- COUNT : 파티션 별로 행 수를 계산한다
- MAX와 MIN : 파티션 별로 최대값과 최소값을 계산한다

<br/>

**행 순서관련 함수**

행 순서관련 함수는 상위 행의 값을 하위에 출력하거나 하위 행의 값을 상위 행에 출력할 수 있다.

- FIRST_VALUE : 파티션에서 가장 처음 나오는 값 (MIN 함수와 동일)
- LAST_VALUE : 파티션에서 가장 마지막에 나오는 값 (MAX 함수와 동일)
- LAG : 이전 행을 가지고온다
- LEAD : 특정 위치의 행을 가지고 온다 (기본 값은 1이다)

<br/>

**비율 관련 함수**

비율 관련 함수는 누적 백분율, 순서별 백분율, 파티션을 N분으로 분할한 결과 등을 조회할 수 있다.

- CUME_DIST : 파티션 전체 건수에서 현재 행보다 작거나 같은 건수에 대한 누적 백분율 조회 (0~1 사이 값)
- PERCENT_RANK : 파티션에서 제일 먼저 나온 것을 0으로 제일 나중에 나온 것을 1로 하여 값이 아닌 행의 순서별 백분율 조회
- NTILE : 파티션별로 전체 건수를 ARGUMENT 값으로 N 등분한 결과를 조회
- RATIO_TO_REPORT : 파티션 내에 전체 SUM(칼럼)에 대한 행 별 칼럼 값의 백분율을 소수점까지 조회

<br/>

**테이블 파티션**

- 파티션은 대용량의 테이블을 여러 개의 데이터 파일에 분리해서 저장하게 한다.

- 데이터를 조회할 때 데이터의 범위를 줄여서 성능을 향상시킨다.

- Range Partition : 테이블의 칼럼 중에서 값의 범위를 기준으로 여러 개의 파티션으로 데이터를 나누어 저장

- List Partition : 특정 값을 기준으로 분할하는 방법

- Hash Partition : 해시함수를 사용해서 데이터를 분할 (관리 시스템이 알아서 분할)

- Composite Partition : 여러 개의 파티션 기법을 조합해서 사용

- 파티션 인덱스

  | 구분               | 주요 내용                                     |
  | ------------------ | --------------------------------------------- |
  | Global Index       | 여러 개의 파티션에서 하나의 인덱스를 사용한다 |
  | Local Index        | 해당 파티션 별로 각자의 인덱스를 사용한다     |
  | Prefixed Index     | 파티션 키와 인덱스 키가 동일하다              |
  | Non Prefixed Index | 파티션 키와 인덱스 키가 다르다                |

<br/>

# 3. SQL 최적화의 원리

**옵티마이저**

- 옵티마이저는 SQL의 실행계획을 수립하고 SQL을 실행하는 데이터베이스 관리 시스템의 소프트웨어이다.
- 옵티마이저의 실행계획은 SQL 성능에 아주 중요한 역할을 한다
- 실행계획 중에서 최저비용을 가지고 있는 하나를 선택해서 SQL을 실행한다
- SQL 실행계획은 PLAN_TABLE에 저장한다
- 옵티마이저는 <u>기본적으로 비용 기반 옵티마이저</u>를 사용한다

<br/>

**옵티마이저 실행 방법**

<img src="https://i.ibb.co/ccRp3Ky/image.jpg" alt="image" border="0">

- 옵티마이저 엔진

  | 옵티마이저        | 설명                                                     |
  | ----------------- | -------------------------------------------------------- |
  | Query Transformer | SQL문을 효율적으로 실행하기 위해서 옵티마이저가 변환한다 |
  | Estimator         | 통계정보를 사용해서 SQL 실행비용을 계산한다              |
  | Plan Generator    | SQL을 실행할 실행계획을 수립한다                         |

<br/>

**비용 기반 옵티마이저**

- 비용 기반 옵티마이저는 오브젝트 통계 및 시스템 통계를 사용해서 총 비용을 계산한다
- 총비용이 적은 쪽으로 실행계획을 수립한다. 단, 비용 기반 옵티마이저에서 통계정보가 부적절한 경우 성능 저하가 발생할 수 있다.
- 총비용이라는 것은 SQL문을 실행하기 위해서 예상되는 소요시간 혹은 자원의 사용량을 의미한다.

<br/>

**인덱스**

- 인덱스는 데이터를 빠르게 검색할 수 있는 방법을 제공한다
- 하나의 테이블에 여러 개의 인덱스를 생성할 수 있고 하나의 인덱스는 여러 개의 칼럼으로 구성될 수 있다
- 테이블 생성 시 자동으로 인덱스가 생성된다 (이름은 SYSXXXX)
- 인덱스의 구조는 Root Block, Branch Block, Leaf Block으로 구성되고, Root Block은 인덱스 트리에서 가장 상위에 있는 노드를 의미하며 Branch Block은 다음 단계의 주소를 가지고 있는 포인터(Pointer)로 되어 있다.
- Leaf Block은 인덱스 키와 ROWID로 구성되고 인덱스 키는 정렬되어서 저장되어 있다.
- 인덱스 생성은 'CREATE INDEX'로 가능하다 (기본적으로 오름차순이다)

<br/>

**인덱스 스캔**

1. 인덱스 유일 스캔
   - 인덱스의 키 값이 중복되지 않는 경우, 해당 인덱스를 사용할 때 발생한다
2. 인덱스 범위 스캔
   - 특정 범위를 조회하는 WHERE문을 사용할 경우 발생한다
3. 인덱스 전체 스캔
   - 인덱스 키가 많은 경우에 Leaf Block의 처음부터 끝까지 전체를 읽어 들인다

<br/>

**옵티마이저 조인**

1. Nested Loop 조인
   - Nested Loop 조인은 하나의 테이블에서 데이터를 먼저 찾고 그다음 테이블을 조인하는 방식
   - 먼저 조회되는 테이블을 외부 테이블이라고 하고 그다음 조회되는 테이블을 내부 테이블이라고 한다
   - 외부 테이블의 크기가 작은 것을 먼저 찾는 것이 중요하다
   - RANDOM ACCESS의 양을 줄여야 성능이 향상된다
2. Sort Merge 조인
   - Sort Merge 조인은 두 개의 테이블을 SORT_AREA라는 메모리 공간에 모두 로딩하고 SORT를 수행한다
   - 데이터 양이 많아 지면 성능이 떨어지게 된다
3. Hash 조인
   - Hash 조인은 두 개의 테이블 중에서 작은 테이블을 HASH 메모리에 로딩하고 두 개의 테이블의 조인 키를 사용해서 해시 테이블을 생성한다
   - CPU 연산을 많이 한다